import Constants from 'expo-constants';
import { supabase } from './supabase';
import { StoryGenerationRequest, StoryGenerationResponse, StoryChapter, StoryBook, StoryOutlineRequest } from '../types';
import { OpenAIProvider, GeminiProvider, ClaudeProvider } from '../ai/storyProviders';
import { getRandomThemeImage } from '../constants/themeImages';

export class AIStoryService {
  private providers: Map<string, any> = new Map();
  private defaultProvider: string;

  constructor() {
    this.defaultProvider = Constants.expoConfig?.extra?.defaultAIProvider || process.env.EXPO_PUBLIC_DEFAULT_AI_PROVIDER || 'openai';
    this.initializeProviders();
  }

  private initializeProviders() {
    console.log('ðŸ”‘ Initializing AI providers...');
    console.log('ðŸ”‘ Default provider:', this.defaultProvider);
    console.log('ðŸ”‘ Expo config extra:', Constants.expoConfig?.extra);
    
    // Initialize OpenAI
    const openaiKey = Constants.expoConfig?.extra?.openaiApiKey || process.env.EXPO_PUBLIC_OPENAI_API_KEY;
    console.log('ðŸ”‘ OpenAI key found:', !!openaiKey, openaiKey ? `${openaiKey.substring(0, 10)}...` : 'none');
    if (openaiKey && !openaiKey.includes('your-') && !openaiKey.includes('sk-your-')) {
      this.providers.set('openai', new OpenAIProvider(openaiKey));
      console.log('ðŸ”‘ OpenAI provider initialized');
    }

    // Initialize Gemini - Prioritize environment variables over app.json
    const geminiKey = process.env.EXPO_PUBLIC_GEMINI_API_KEY || Constants.expoConfig?.extra?.geminiApiKey;
    console.log('ðŸ”‘ Gemini key found:', !!geminiKey, geminiKey ? `${geminiKey.substring(0, 10)}...` : 'none');
    console.log('ðŸ”‘ Gemini key from app.json:', Constants.expoConfig?.extra?.geminiApiKey);
    console.log('ðŸ”‘ Gemini key from env:', process.env.EXPO_PUBLIC_GEMINI_API_KEY);
    
    if (geminiKey && !geminiKey.includes('your-') && geminiKey.length > 10) {
      this.providers.set('gemini', new GeminiProvider(geminiKey));
      console.log('ðŸ”‘ Gemini provider initialized');
    } else {
      console.log('ðŸ”‘ Gemini provider NOT initialized - key invalid or missing');
    }

    // Initialize Claude
    const claudeKey = Constants.expoConfig?.extra?.claudeApiKey || process.env.EXPO_PUBLIC_CLAUDE_API_KEY;
    console.log('ðŸ”‘ Claude key found:', !!claudeKey, claudeKey ? `${claudeKey.substring(0, 10)}...` : 'none');
    if (claudeKey && !claudeKey.includes('your-')) {
      this.providers.set('claude', new ClaudeProvider(claudeKey));
      console.log('ðŸ”‘ Claude provider initialized');
    }
    
    console.log('ðŸ”‘ Total providers initialized:', this.providers.size);
    console.log('ðŸ”‘ Available providers:', Array.from(this.providers.keys()));
  }

  async generateStory(request: StoryGenerationRequest): Promise<StoryGenerationResponse> {
    try {
      // Get the provider
      const provider = this.providers.get(this.defaultProvider);
      if (!provider) {
        return {
          success: false,
          error: `No AI provider configured for: ${this.defaultProvider}`,
        };
      }

      // If it's Gemini, we now know the available models from the listing

      // Generate story with primary provider
      let result = await provider.generateStory(request);
      
      // If primary provider fails, try fallback providers
      if (!result.success) {
        console.warn(`Primary provider ${this.defaultProvider} failed, trying fallbacks`);
        
        for (const [providerName, fallbackProvider] of this.providers) {
          if (providerName !== this.defaultProvider) {
            result = await fallbackProvider.generateStory(request);
            if (result.success) {
              console.log(`Fallback provider ${providerName} succeeded`);
              break;
            }
          }
        }
      }

      // If all providers fail, use curated fallback
      if (!result.success) {
        console.log('ðŸ“š All AI providers failed, using fallback story');
        return await this.generateFallbackStory(request);
      }

      // Save to database
      if (result.chapter) {
        // Fix: Ensure story_book_id is passed from request to chapter before saving
        if (request.bookId) {
            result.chapter.story_book_id = request.bookId;
        }

        // Fix: Apply title override from outline if present, to correct "Chapter 10" or bad titles
        if (request.chapterTitle && (result.chapter.title.includes('A New Adventure') || !result.chapter.title)) {
             result.chapter.title = request.chapterTitle;
        } else if (request.chapterTitle && !result.chapter.title.includes(request.chapterTitle) && !result.chapter.title.toLowerCase().includes('chapter')) {
             result.chapter.title = `Chapter ${request.chapterNumber}: ${request.chapterTitle}`;
        }

        // Assign a random cover image if one wasn't generated by AI (Premium Story Cover functionality)
        if (!result.chapter.image_url) {
            result.chapter.image_url = getRandomThemeImage(request.worldTheme);
        }

        const savedChapter = await this.saveChapterToDatabase(result.chapter);
        if (savedChapter) {
          result.chapter = savedChapter;
        } else {
          // If save failed, mark result as failed to prevent book.current_chapter from being updated incorrectly
          console.error('Failed to save chapter to database, marking result as failed');
          result.success = false;
          result.error = 'Failed to save chapter to database';
          result.chapter = undefined;
        }
      }

      return result;
    } catch (error) {
      console.error('AI Story Service error:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }

  async startNewBook(childId: string, worldTheme: string): Promise<StoryBook | null> {
    try {
      console.log('ðŸ“š Starting new book for child:', childId, 'Theme:', worldTheme);

      // 1. Get child info
      const { data: child, error: childError } = await supabase
        .from('children')
        .select('name, age_bracket')
        .eq('id', childId)
        .single();

      if (childError || !child) {
        console.error('ðŸ“š Error fetching child for new book:', childError);
        return null;
      }

      // 2. Generate Outline
      const provider = this.providers.get(this.defaultProvider);
      if (!provider) {
        console.error('ðŸ“š No provider available for outline generation');
        return null;
      }

      const outlineRequest: StoryOutlineRequest = {
        childId,
        childName: child.name,
        ageBracket: child.age_bracket,
        worldTheme: worldTheme as any,
        totalChapters: 10
      };

      console.log('ðŸ“š Generating outline with request:', outlineRequest);
      const outline = await provider.generateStoryOutline(outlineRequest);

      if (!outline || outline.length === 0) {
        console.error('ðŸ“š Failed to generate outline');
        return null;
      }
      
      // Use the title from the first chapter or generic
      const bookTitle = `The ${worldTheme.replace('_', ' ')} Adventure`;

      // 3. Save Book
      const { data: book, error: bookError } = await supabase
        .from('story_books')
        .insert({
          child_id: childId,
          title: bookTitle,
          theme: worldTheme,
          status: 'active',
          total_chapters: 10,
          current_chapter: 1,
          outline: outline
        })
        .select()
        .single();

      if (bookError) {
        console.error('ðŸ“š Error saving book:', bookError);
        return null;
      }

      console.log('ðŸ“š New book created:', book.id);
      return book;
    } catch (error) {
      console.error('ðŸ“š Error in startNewBook:', error);
      return null;
    }
  }

  private async generateFallbackStory(request: StoryGenerationRequest): Promise<StoryGenerationResponse> {
    // Curated fallback stories based on world theme
    const fallbackStories = {
      magical_forest: {
        title: `Chapter ${request.chapterNumber}: The Helpful Fairy`,
        content: `In the magical forest, ${request.childName} discovered a tiny fairy who needed help organizing her flower garden. The fairy was so grateful for ${request.childName}'s help that she granted them a special wish. ${request.childName} wished for all children to be happy and helpful, just like they had been today. The fairy smiled and sprinkled magic dust, making the wish come true. From that day forward, ${request.childName} knew that helping others was the greatest magic of all.`
      },
      space_adventure: {
        title: `Chapter ${request.chapterNumber}: The Friendly Alien`,
        content: `During their space adventure, ${request.childName} met a friendly alien named Zyx who was having trouble keeping their spaceship clean. ${request.childName} helped Zyx organize the control room and learned about different planets in the galaxy. Zyx was so impressed by ${request.childName}'s helpfulness that they gave them a special space badge. ${request.childName} felt proud to be a helpful space explorer and promised to always lend a hand when others needed it.`
      },
      underwater_kingdom: {
        title: `Chapter ${request.chapterNumber}: The Mermaid's Treasure`,
        content: `In the underwater kingdom, ${request.childName} helped a young mermaid named Coral organize her seashell collection. Coral had so many beautiful shells but couldn't find the ones she needed. ${request.childName} carefully sorted the shells by color and size, making Coral's collection neat and organized. As a thank you, Coral shared a magical pearl with ${request.childName}, which glowed softly and reminded them that helping others makes the whole ocean a brighter place.`
      }
    };

    const fallbackStory = fallbackStories[request.worldTheme] || fallbackStories.magical_forest;

    const chapter: StoryChapter = {
      id: '', // Will be set by database
      child_id: request.childId,
      story_book_id: request.bookId, // Include story_book_id to avoid legacy constraint violation
      chapter_number: request.chapterNumber,
      title: fallbackStory.title,
      content: fallbackStory.content,
      world_theme: request.worldTheme,
      image_url: getRandomThemeImage(request.worldTheme),
      unlocked_at: new Date().toISOString(),
      is_read: false,
      created_at: new Date().toISOString(),
    };

    const savedChapter = await this.saveChapterToDatabase(chapter);

    if (!savedChapter) {
      console.error('Failed to save fallback chapter to database');
      return {
        success: false,
        error: 'Failed to save fallback chapter to database',
        fallbackUsed: true,
      };
    }

    return {
      success: true,
      chapter: savedChapter,
      fallbackUsed: true,
    };
  }

  private async saveChapterToDatabase(chapter: StoryChapter): Promise<StoryChapter | null> {
    try {
      const { data, error } = await supabase
        .from('story_chapters')
        .insert({
          child_id: chapter.child_id,
          story_book_id: chapter.story_book_id,
          chapter_number: chapter.chapter_number,
          title: chapter.title,
          content: chapter.content,
          world_theme: chapter.world_theme,
          unlocked_at: chapter.unlocked_at,
          is_read: chapter.is_read,
        })
        .select()
        .single();

      if (error) {
        console.error('Error saving chapter to database:', error);
        return null;
      }

      return data;
    } catch (error) {
      console.error('Error in saveChapterToDatabase:', error);
      return null;
    }
  }

  async unlockStoryForChores(childId: string, completedChoreIds: string[]): Promise<StoryChapter | null> {
    try {
      console.log('ðŸ“š Starting story generation for child:', childId);
      console.log('ðŸ“š Completed chore IDs:', completedChoreIds);
      
      // Get child info
      const { data: child, error: childError } = await supabase
        .from('children')
        .select('name, age, age_bracket, world_theme')
        .eq('id', childId)
        .single();

      if (childError || !child) {
        console.error('ðŸ“š Error fetching child:', childError);
        return null;
      }

      // Get completed chores
      const { data: chores, error: choresError } = await supabase
        .from('chore_completions')
        .select(`
          chore_id,
          chores (
            title,
            description
          )
        `)
        .in('id', completedChoreIds)
        .eq('status', 'approved');

      if (choresError || !chores) {
        console.error('ðŸ“š Error fetching chores:', choresError);
        return null;
      }

      const completedChoreTitles = chores.map(c => c.chores?.title || 'completed chore');

      // CHECK FOR ACTIVE BOOK
      let { data: activeBook } = await supabase
        .from('story_books')
        .select('*')
        .eq('child_id', childId)
        .eq('status', 'active')
        .single();

      // If no active book, create one
      if (!activeBook) {
        console.log('ðŸ“š No active book found, creating new one...');
        activeBook = await this.startNewBook(childId, child.world_theme);
        if (!activeBook) {
             console.error('ðŸ“š Failed to create new book');
             return null;
        }
      }

      // Calculate Next Chapter Number based on what's already in the chapters table for this book
      const { data: existingChapters } = await supabase
        .from('story_chapters')
        .select('chapter_number')
        .eq('story_book_id', activeBook.id)
        .order('chapter_number', { ascending: false })
        .limit(1);
        
      const lastUnlocked = existingChapters?.[0]?.chapter_number || 0;
      const nextChapterNum = lastUnlocked + 1;

      if (nextChapterNum > activeBook.total_chapters) {
          console.log('ðŸ“š Book completed!');
          // Mark book as completed
          await supabase
            .from('story_books')
            .update({ 
                status: 'completed', 
                completed_at: new Date().toISOString() 
            })
            .eq('id', activeBook.id);
            
          // Optionally notify or return a special status
          return null; 
      }

      // Get synopsis from outline
      // Outline is JSONB, so we need to cast or treat as any
      const outline = (activeBook.outline as any[]) || [];
      const outlineChapter = outline.find((o: any) => o.chapter_number === nextChapterNum);
      const chapterSynopsis = outlineChapter?.synopsis || '';
      const chapterTitle = outlineChapter?.title || `Chapter ${nextChapterNum}`;

      console.log(`ðŸ“š Generating Chapter ${nextChapterNum}: ${chapterTitle}`);
      console.log(`ðŸ“š Synopsis: ${chapterSynopsis}`);

      // Get previous chapter content for context
      let previousChapterSummary: string | undefined = undefined;
      if (nextChapterNum > 1) {
          const { data: previousChapter } = await supabase
            .from('story_chapters')
            .select('content')
            .eq('story_book_id', activeBook.id)
            .eq('chapter_number', nextChapterNum - 1)
            .single();
            
          if (previousChapter?.content) {
            const content = previousChapter.content;
            const startIndex = Math.max(0, content.length - 800);
            previousChapterSummary = content.substring(startIndex);
          }
      }

      const request: StoryGenerationRequest = {
        childId,
        childName: child.name,
        ageBracket: child.age_bracket,
        worldTheme: child.world_theme,
        completedChores: completedChoreTitles,
        previousChapterSummary,
        chapterNumber: nextChapterNum,
        bookId: activeBook.id,
        chapterSynopsis,
        chapterTitle
      };

      const result = await this.generateStory(request);
      
      if (result.success && result.chapter) {
        // Ensure chapter has the correct title from outline if AI changed it too much, 
        // or use AI title if it's better. Let's stick to AI title but maybe influence it.
        // And link to book
        result.chapter.story_book_id = activeBook.id;
        result.chapter.chapter_number = nextChapterNum; // Ensure correct number
        
        // Use the outline title if the generated title is a fallback or very generic
        if (chapterTitle && (result.chapter.title.includes('A New Adventure') || !result.chapter.title)) {
             result.chapter.title = chapterTitle;
        } else if (chapterTitle && !result.chapter.title.includes(chapterTitle) && !result.chapter.title.toLowerCase().includes('chapter')) {
             // If the generated title doesn't look like a chapter title but we have one from outline
             result.chapter.title = `Chapter ${nextChapterNum}: ${chapterTitle}`;
        }
        
        // Save happens inside generateStory -> saveChapterToDatabase, 
        // but we need to make sure saveChapterToDatabase handles the new fields.
        // Wait, generateStory calls saveChapterToDatabase internally.
        // I updated saveChapterToDatabase above.
        
        // Update Book Progress
        await supabase
            .from('story_books')
            .update({ current_chapter: nextChapterNum })
            .eq('id', activeBook.id);
            
        console.log('ðŸ“š Story generated successfully:', result.chapter.title);
        
        // Update story progress (Legacy table support)
        await this.updateStoryProgress(childId, child.world_theme, nextChapterNum);
        
        // Create notification
        await this.createStoryUnlockNotification(childId, result.chapter.title);
        
        return result.chapter;
      } else {
        console.warn('ðŸ“š Story generation failed:', result.error);
        return null;
      }
    } catch (error) {
      console.error('ðŸ“š Error in unlockStoryForChores:', error);
      return null;
    }
  }

  private async updateStoryProgress(childId: string, worldTheme: string, chapterNumber: number) {
    try {
      // First, try to get existing progress
      const { data: existingProgress } = await supabase
        .from('story_progress')
        .select('*')
        .eq('child_id', childId)
        .eq('world_theme', worldTheme)
        .single();

      if (existingProgress) {
        // Update existing progress
        const { error } = await supabase
          .from('story_progress')
          .update({
            current_chapter: Math.max(existingProgress.current_chapter, chapterNumber),
            total_chapters_unlocked: Math.max(existingProgress.total_chapters_unlocked, chapterNumber),
            updated_at: new Date().toISOString(),
          })
          .eq('child_id', childId)
          .eq('world_theme', worldTheme);

        if (error) {
          console.error('ðŸ“š Error updating existing story progress:', error);
        } else {
          console.log('ðŸ“š Story progress updated successfully');
        }
      } else {
        // Create new progress record
        const { error } = await supabase
          .from('story_progress')
          .insert({
            child_id: childId,
            world_theme: worldTheme,
            current_chapter: chapterNumber,
            total_chapters_unlocked: chapterNumber,
          });

        if (error) {
          console.error('ðŸ“š Error creating new story progress:', error);
        } else {
          console.log('ðŸ“š New story progress created successfully');
        }
      }
    } catch (error) {
      console.error('ðŸ“š Error in updateStoryProgress:', error);
    }
  }

  private async createStoryUnlockNotification(childId: string, chapterTitle: string) {
    try {
      // Use the NotificationService instead of direct database insert
      // This handles RLS policies properly
      const { NotificationService } = await import('./notificationService');
      
      const notification = await NotificationService.notifyStoryUnlock(childId, chapterTitle);
      
      if (notification) {
        console.log('ðŸ“š Story unlock notification created successfully');
      } else {
        console.warn('ðŸ“š Failed to create story unlock notification');
      }
    } catch (error) {
      console.error('ðŸ“š Error in createStoryUnlockNotification:', error);
    }
  }
}

// Export singleton instance
export const aiStoryService = new AIStoryService();
